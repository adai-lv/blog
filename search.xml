<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java OOM之可用虚拟内存异常</title>
      <link href="/articles/java/oom-zhi-ke-yong-xu-ni-nei-cun-yi-chang.html"/>
      <url>/articles/java/oom-zhi-ke-yong-xu-ni-nei-cun-yi-chang.html</url>
      
        <content type="html"><![CDATA[<p>分析什么情况会导致可用虚拟内存异常：<strong><font color="red">java.lang.OutOfMemoryError:Kill process or sacrifice child</font></strong> 出现，并提供示例代码的同时为您提供解决指南。</p><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>操作系统是建立在进程的概念之上，这些进程在内核中作业，其中有一个非常特殊的进程，名叫“内存杀手（Out of memory killer）”。当内核检测到系统内存不足时，OOM killer被激活，然后选择一个进程杀掉。哪一个进程这么倒霉呢？选择的算法和想法都很朴实：谁占用内存最多，谁就被干掉。如果你对OOM Killer感兴趣的话，建议你阅读一下这篇文章：<a href="https://www.vpsee.com/2013/10/how-to-configure-the-linux-oom-killer/" target="_blank" rel="noopener">理解和配置 Linux 下的 OOM Killer</a>。</p><p><img src="https://cdn.jsdelivr.net/gh/lvmaohai/blog/images/article/java-oom-07.png" alt="OOM Killer"></p><p>当可用虚拟虚拟内存(包括交换空间)消耗到让整个操作系统面临风险时，就会产生 <font color="red">Out of memory:Kill process or sacrifice child</font> 错误。在这种情况下，OOM Killer会选择“流氓进程”并杀死它。</p><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>默认情况下，<strong>Linux内核</strong>允许进程请求比系统中可用内存更多的内存，但大多数进程实际上并没有使用完他们所分配的内存。这就跟现实生活中的宽带运营商类似，他们向所有消费者出售一个100M的带宽，远远超过用户实际使用的带宽，一个10G的链路可以非常轻松的服务100个(10G/100M)用户，但实际上宽带运行商往往会把10G链路用于服务150人或者更多，以便让链路的利用率更高，毕竟空闲在那儿也没什么意义。</p><p>Linux内核采用的机制跟宽带运营商差不多，一般情况下都没有问题，但当大多数应用程序都消耗完自己的内存时，麻烦就来了，因为这些应用程序的内存需求加起来超出了物理内存（包括 swap）的容量，内核（OOM killer）必须杀掉一些进程才能腾出空间保障系统正常运行。</p><h2 id="场景示例"><a href="#场景示例" class="headerlink" title="场景示例"></a>场景示例</h2><p>当你在Linux上运行如下代码：</p><pre><code>public static void main(String[] args){    List&lt;int[]&gt; l = new java.util.ArrayList();    for (int i = 10000; i &lt; 100000; i++) {        try {            l.add(new int[100000000]);        } catch (Throwable t) {            t.printStackTrace();        }    }}</code></pre><p>在Linux的系统日志中<font color="red">/var/log/kern.log</font>会出现以下日志：</p><pre><code>Feb  7 21:30:59 bigo kernel: [70667120.897649] Out of memory: Kill process 29957 (java) score 366 or sacrifice childFeb  7 21:30:59 bigo kernel: [70667120.897701] Killed process 29957 (java) total-vm:2532680kB, anon-rss:1416508kB, file-rss:0kB</code></pre><p>注意：你可能需要调整交换文件和堆大小，否则你将很快见到熟悉的Java heap space异常。在测试用例中，使用-Xmx2g指定的2g堆，并具有以下交换配置：</p><pre><code>swapoff -a dd if=/dev/zero of=swapfile bs=1024 count=655360mkswap swapfileswapon swapfile</code></pre><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>解决这个问题最有效也是最直接的方法就是升级内存，其他方法诸如：调整OOM Killer配置、水平扩展应用，将内存的负载分摊到若干小实例上等</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> OOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java OOM之数组大小限制异常</title>
      <link href="/articles/java/oom-zhi-shu-zu-da-xiao-xian-zhi-yi-chang.html"/>
      <url>/articles/java/oom-zhi-shu-zu-da-xiao-xian-zhi-yi-chang.html</url>
      
        <content type="html"><![CDATA[<p>分析什么情况会导致数组大小限制异常：<strong><font color="red">java.lang.OutOfMemoryError:Requested array size exceeds VM limit</font></strong> 出现，并提供示例代码的同时为您提供解决指南。</p><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>Java对应用程序可以分配的最大数组大小有限制。不同平台限制有所不同，但通常在1到21亿个元素之间。</p><p><img src="https://cdn.jsdelivr.net/gh/lvmaohai/blog/images/article/java-oom-06.png" alt=""></p><p>当你遇到 <strong><font color="red">java.lang.OutOfMemoryError:Requested array size exceeds VM limit</font></strong> 错误时，意味着你的应用程序试图分配大于Java虚拟机可以支持的数组。</p><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>该错误由 <strong>JVM</strong> 中的<strong>native code</strong>抛出。<strong>JVM</strong> 在为数组分配内存之前，会执行特定于平台的检查：分配的数据结构是否在此平台中是可寻址的。</p><p>你很少见到这个错误是因为Java数组的索引是int类型。Java中的最大正整数为2 ^ 31 - 1 = 2,147,483,647。 并且平台特定的限制可以非常接近这个数字，例如：64位macOS，运行<strong>Jdk1.8</strong>可以初始化数组的长度高达2,147,483,645（Integer.MAX_VALUE-2）。如果再将数组的长度增加1到Integer.MAX_VALUE-1会导致熟悉的OutOfMemoryError：</p><pre><code>Exception in thread "main" java.lang.OutOfMemoryError: Requested array size exceeds VM limit</code></pre><p>但是，在使用OpenJDK 6的32位Linux上，在分配具有大约11亿个元素的数组时，您将遇到 <strong><font color="red">java.lang.OutOfMemoryError:Requested array size exceeds VM limit</font></strong> 的错误。 要理解你的特定环境的限制，运行下文中描述的小测试程序。</p><h2 id="场景示例"><a href="#场景示例" class="headerlink" title="场景示例"></a>场景示例</h2><pre><code>for (int i = 3; i &gt;= 0; i--) {    try {        int[] arr = new int[Integer.MAX_VALUE-i];        System.out.format("Successfully initialized an array with %,d elements.\n", Integer.MAX_VALUE-i);    } catch (Throwable t) {        t.printStackTrace();    }}</code></pre><p>该示例重复四次，并在每个回合中初始化一个长原语数组。该程序尝试初始化的数组的大小在每次迭代时增加1，最终达到Integer.MAX_VALUE。 现在，当使用Hotspot 7在64位Mac OS X上启动代码片段时，应该得到类似于以下内容的输出：</p><pre><code>java.lang.OutOfMemoryError: Java heap space    at com.phlicode.demo.ArraySize.main(ArraySize.java:8)java.lang.OutOfMemoryError: Java heap space    at com.phlicode.demo.ArraySize.main(ArraySize.java:8)java.lang.OutOfMemoryError: Requested array size exceeds VM limit    at com.phlicode.demo.ArraySize.main(ArraySize.java:8)java.lang.OutOfMemoryError: Requested array size exceeds VM limit    at com.phlicode.demo.ArraySize.main(ArraySize.java:8)</code></pre><p>注意，在出现<strong>Requested array size exceeded VM limit</strong>之前，出现了更熟悉的<strong>java.lang.OutOfMemoryError: Java heap space</strong>。 这是因为初始化2 ^ 31-1个元素的数组需要腾出8G的内存空间，大于JVM使用的默认值。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><strong><font color="red">java.lang.OutOfMemoryError:Requested array size exceeds VM limit</font></strong> 可能会在以下任一情况下出现：</p><ul><li>数组增长太大，最终大小在平台限制和Integer.MAX_INT之间</li><li>你有意分配大于2 ^ 31-1个元素的数组</li></ul><p>在第一种情况下，检查你的代码库，看看你是否真的需要这么大的数组。也许你可以减少数组的大小，或者将数组分成更小的数据块，然后分批处理数据。</p><p>在第二种情况下，记住Java数组是由int索引的。因此，当在平台中使用标准数据结构时，数组不能超过2 ^ 31-1个元素。事实上，在编译时就会出错：error：integer number too large。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> OOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java OOM之交换空间异常</title>
      <link href="/articles/java/oom-zhi-jiao-huan-kong-jian-yi-chang.html"/>
      <url>/articles/java/oom-zhi-jiao-huan-kong-jian-yi-chang.html</url>
      
        <content type="html"><![CDATA[<p>分析什么情况会导致创建<strong>Native线程</strong>异常：<strong><font color="red">java.lang.OutOfMemoryError:Out of swap space</font></strong> 出现，并提供示例代码的同时为您提供解决指南。</p><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>在 JVM 启动的时候，可以通过 -Xmx 等参数来限制 JVM 的最大内存。当 JVM 使用的内存总量超过可用的物理内存时，操作系统就会用到虚拟内存（会将内存中的数据交换到磁盘上去）。</p><p><img src="https://cdn.jsdelivr.net/gh/lvmaohai/blog/images/article/java-oom-05.png" alt=""></p><p>出现 <strong><font color="red">java.lang.OutOfMemoryError:Out of swap space</font></strong> 就意味着交换空间也将耗尽，并且由于缺少物理内存和交换空间，再次尝试分配内存也将失败。</p><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>当应用程序向 <strong>JVM native heap</strong> 请求分配内存失败并且 <strong>native heap</strong> 也即将耗尽时，JVM 会抛出 <strong><font color="red">java.lang.OutOfMemoryError:Out of swap space</font></strong> 错误。该错误消息中包含分配失败的大小（以字节为单位）和请求失败的原因。</p><blockquote><p>Native Heap Memory 是 JVM 内部使用的 Memory，这部分的 Memory 可以通过JDK提供的JNI的方式去访问，这部分Memory效率很高，但是管理需要自己去做，如果没有把握最好不要使用，以防出现内存泄露问题。JVM 使用 Native Heap Memory 用来优化代码载入（JTI代码生成），临时对象空间申请，以及JVM内部的一些操作。</p></blockquote><p>这个问题往往发生在Java进程已经开始交换的情况下，现代的GC算法已经做得足够好了，当面临由于交换引起的延迟问题时，GC暂停的时间往往会让大多数应用程序不能容忍。</p><p><strong><font color="red">java.lang.OutOfMemoryError:Out of swap space</font></strong> 往往是由操作系统级别的问题引起的，例如：</p><ul><li>操作系统配置的交换空间不足。</li><li>系统上的另一个进程消耗所有内存资源。</li></ul><p>还有可能是本地内存泄漏导致应用程序失败，比如：应用程序调用了<strong>native code</strong>连续分配内存，但却没有被释放。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>解决这个问题有几个办法，通常最简单的方法就是增加交换空间，不同平台实现的方式会有所不同，比如在Linux下可以通过如下命令实现：</p><pre><code># 创建并附加一个大小为640MB的新交换文件swapoff -a dd if=/dev/zero of=swapfile bs=1024 count=655360mkswap swapfileswapon swapfile</code></pre><p>Java GC会扫描内存中的数据，如果是对交换空间运行垃圾回收算法会使GC暂停的时间增加几个数量级，因此你应该慎重考虑使用上文增加交换空间的方法。</p><p>如果你的应用程序部署在JVM需要同其他进程激烈竞争获取资源的物理机上，建议将服务隔离到单独的虚拟机中。</p><p>但在许多情况下，您唯一真正可行的替代方案是：</p><ul><li>升级机器以包含更多内存</li><li>优化应用程序以减少其内存占用</li></ul><p>当您转向优化路径时，使用内存转储分析程序来检测内存中的大分配是一个好的开始。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> OOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java OOM之创建Native线程异常</title>
      <link href="/articles/java/oom-zhi-chuang-jian-native-xian-cheng-yi-chang.html"/>
      <url>/articles/java/oom-zhi-chuang-jian-native-xian-cheng-yi-chang.html</url>
      
        <content type="html"><![CDATA[<p>分析什么情况会导致创建<strong>Native线程</strong>异常：<strong><font color="red">java.lang.OutOfMemoryError:Unable to create new native thread</font></strong> 出现，并提供示例代码的同时为您提供解决指南。</p><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>一个思考线程的方法是将线程看着是执行任务的工人，如果你只有一个工人，那么他同时只能执行一项任务，但如果你有十几个工人，就可以同时完成你几个任务。就像这些工人都在物理世界一样，JVM中的线程完成自己的工作也是需要一些空间的，当有足够多的线程却没有那么多的空间时就会像这样：</p><p><img src="https://cdn.jsdelivr.net/gh/lvmaohai/blog/images/article/java-oom-04.png" alt=""></p><p>出现 <strong><font color="red">java.lang.OutOfMemoryError:Unable to create new native thread</font></strong> 就意味着Java应用程序已达到其可以启动线程数量的极限了。</p><p>JVM中可以生成的最大线程数量是由<font color="red">JVM的堆内存大小</font>、<font color="red">Thread的Stack内存大小</font>、<font color="red">系统最大可创建的线程数量（Java线程的实现是基于底层系统的线程机制来实现的，Linux下pthread_create）</font>三个方面影响。具体数量可以根据Java进程可以访问的最大内存（32位系统上一般2G）、堆内存、Thread的Stack内存来估算。</p><p> 在64位Linux系统（CentOS 6， 3G内存）下测试，发现还有一个参数是会限制线程数量：<strong>max user process</strong>（可通过ulimit –a查看，默认值1024，通过ulimit –u可以修改此值）</p><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>当<strong>JVM</strong>向<strong>OS</strong>请求创建一个新线程时，而<strong>OS</strong>却无法创建<strong>新的native线程</strong>时就会抛出<font color="red">Unable to create new native thread</font>错误。一台服务器可以创建的线程数依赖于物理配置和平台，建议运行下文中的示例代码来测试找出这些限制。总体上来说，抛出此错误会经过以下几个阶段：</p><ul><li>运行在<strong>JVM</strong>内的应用程序请求创建一个新的线程</li><li><strong>JVM</strong>向<strong>OS</strong>请求创建一个新的native线程</li><li><strong>OS</strong>尝试创建一个新的native线程，这时需要分配内存给新的线程</li><li><strong>OS</strong>拒绝分配内存给线程，因为32位<strong>Java进程</strong>已经耗尽内存地址空间（2-4GB内存地址已被命中）或者<strong>OS的虚拟内存</strong>已经完全耗尽</li><li><strong>Unable to create new native thread</strong>错误将被抛出</li></ul><h2 id="场景示例"><a href="#场景示例" class="headerlink" title="场景示例"></a>场景示例</h2><p>下面的示例不能的创建并启动新的线程。当代码运行时，很快达到<strong>OS</strong>的线程数限制，并抛出<strong>Unable to create new native thread</strong>错误。</p><pre><code>public class TestNativeOutOfMemoryError {    public static void main(String... args) {        while (true) {            new Thread(() -&gt; {                try {                    Thread.sleep(10000000);                } catch (InterruptedException e) {                }            }).start();        }    }}// 运行代码$ javac TestNativeOutOfMemoryError.java$ java TestNativeOutOfMemoryError</code></pre><p>运行结果：</p><pre><code>Exception in thread "main" java.lang.OutOfMemoryError: unable to create new native thread    at java.lang.Thread.start0(Native Method)    at java.lang.Thread.start(Thread.java:717)    at TestNativeOutOfMemoryError.main(TestNativeOutOfMemoryError.java:11)</code></pre><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>有时，你可以通过在<strong>OS</strong>级别增加线程数限制来绕过这个错误。如果你限制了JVM可在用户空间创建的线程数，那么你可以检查并增加这个限制：</p><pre><code>// macOS 10.14上执行$ ulimit -u709</code></pre><p>当你的应用程序产生成千上万的线程，并抛出此异常，表示你的程序已经出现了很严重的编程错误，我不觉得应该通过修改参数来解决这个问题，不管是<strong>OS</strong>级别的参数还是<strong>JVM</strong>启动参数。</p><p>更可取的办法是：</p><ul><li>分析你的应用是否真的需要创建如此多的线程来完成任务？</li><li>是否可以使用线程池或者说线程池的数量是否合适？</li><li>是否可以更合理的拆分业务来实现？</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> OOM </tag>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java OOM之GC开销限制异常</title>
      <link href="/articles/java/oom-zhi-gc-kai-xiao-xian-zhi-yi-chang.html"/>
      <url>/articles/java/oom-zhi-gc-kai-xiao-xian-zhi-yi-chang.html</url>
      
        <content type="html"><![CDATA[<p>分析什么情况会导致<strong>GC</strong>开销限制异常：<strong><font color="red">java.lang.OutOfMemoryError: GC overhead limit exceeded</font></strong> 出现，并提供示例代码的同时为您提供解决指南。</p><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>Java运行时环境（<strong>JRE</strong>）包含一个内置的垃圾回收进程，而在许多其他的编程语言中，开发者需要手动分配和释放内存。</p><p>Java应用程序只需要<strong>开发者分配内存</strong>，每当在内存中特定的空间不再使用时，一个单独的垃圾收集进程会清空这些内存空间。</p><p><strong>GC overhead limt exceed</strong> 检查是 <strong>Hotspot VM 1.6</strong> 定义的一个策略，通过统计<strong>GC时间</strong>来预测是否要<strong>OOM</strong>了，提前抛出异常，防止<strong>OOM</strong>发生。Sun 官方对此的定义是：“并行/并发回收器在 <strong><font color="red">GC回收时间过长</font></strong> 时会抛出<strong>OutOfMemroyError</strong>，用来避免内存过小造成应用不能正常工作。过长的定义是：<font color="red">超过98%的时间用来做GC并且回收了不到2%的堆内存</font>。“</p><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p><strong><font color="red">java.lang.OutOfMemoryError: GC overhead limit exceeded</font></strong> 异常是一个信号，示意你的应用程序在垃圾收集上花费了太多时间但却没有什么卵用。默认花费超过<font color="red">98%</font>的时间用来做<strong>GC</strong>并且回收了不到<font color="red">2%</font>的堆内存时将会抛出此错误。那如果没有此限制会发生什么呢？<strong>GC</strong>进程将被重启，<font color="red">100%</font>的<strong>CPU</strong>将用于<strong>GC</strong>，而没有<strong>CPU</strong>资源用于其他正常的工作。如果一个工作本来只需要几毫秒即可完成，现在却需要几分钟才能完成，我想这种结果谁都没有办法接受。</p><p>所以 <strong><font color="red">java.lang.OutOfMemoryError: GC overhead limit exceeded</font></strong> 也可以看做是一个<font color="red">fail-fast（快速失败）</font>实战的实例。</p><h2 id="场景示例"><a href="#场景示例" class="headerlink" title="场景示例"></a>场景示例</h2><p>下面的代码初始化一个map并在无限循环中不停的添加键值对，运行后将会抛出 <strong>GC overhead limit exceeded</strong> 错误：</p><pre><code>import java.util.Map;import java.util.Random;public class WrapperTest {    public static void main(String args[]) throws Exception {        Map map = System.getProperties();        Random r = new Random();        while (true) {            map.put(r.nextInt(), "value");        }    }}// 编译和运行程序$ javac WrapperTest.java$ java WrapperTest</code></pre><p>正如你所预料的那样，程序不能正常的结束，事实上，当使用如下参数启动程序时：</p><pre><code>$ java -Xmx100m -XX:+UseParallelGC WrapperTest</code></pre><p>很快就可以看到程序抛出 <strong><font color="red">java.lang.OutOfMemoryError: GC overhead limit exceeded</font></strong> 异常。</p><pre><code>Exception in thread "main" java.lang.OutOfMemoryError: GC overhead limit exceeded    at java.util.Hashtable.addEntry(Hashtable.java:436)    at java.util.Hashtable.put(Hashtable.java:477)    at WrapperTest.main(WrapperTest.java:9)</code></pre><p>如果在启动时设置不同的堆空间大小或者使用不同的GC算法，比如这样：</p><ul><li><p>设置堆空间偏小，启动命令如下：</p><pre><code>  $ java -Xmx10m -XX:+UseParallelGC WrapperTest</code></pre><p>  将看到如下错误：</p><pre><code>  Exception in thread "main" java.lang.OutOfMemoryError: Java heap space      at java.util.Hashtable.rehash(Hashtable.java:402)      at java.util.Hashtable.addEntry(Hashtable.java:426)      at java.util.Hashtable.put(Hashtable.java:477)      at WrapperTest.main(WrapperTest.java:9)</code></pre></li><li><p>使用<strong>ConcMarkSweepGC</strong>算法：-XX:+UseConcMarkSweepGC，启动命令如下：</p><pre><code>  $ java -Xmx100m -XX:+UseConcMarkSweepGC WrapperTest</code></pre><p>  将看到如下错误：</p><pre><code>  Exception in thread "main"  Exception: java.lang.OutOfMemoryError thrown from the UncaughtExceptionHandler in thread "main"</code></pre><p>  错误已经被默认的异常处理程序捕获，并且没有任何错误的堆栈信息输出。</p></li><li><p>使用<strong>G1GC</strong>算法：-XX:+UseG1GC，启动命令如下：</p><pre><code>  $ java -Xmx100m -XX:+UseG1GC WrapperTest</code></pre><p>  将看到如下错误：</p><pre><code>  Exception: java.lang.OutOfMemoryError thrown from the UncaughtExceptionHandler in thread "main"</code></pre><p>  错误已经被默认的异常处理程序捕获，并且没有任何错误的堆栈信息输出。</p></li></ul><p>以上这些变化可以说明，在资源有限的情况下，你根本无法无法预测你的应用是怎样挂掉的，什么时候会挂掉，所以在开发时，你不能仅仅保证自己的应用程序在特定的环境下正常运行。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>首先是一个毫无诚意的解决方案，如果你仅仅是不想看到 <strong><font color="red">java.lang.OutOfMemoryError: GC overhead limit exceeded</font></strong> 异常的错误信息，可以在应用程序启动时添加如下JVM参数：</p><pre><code>// 关闭GC开销限制策略-XX:-UseGCOverheadLimit</code></pre><p>但是强烈建议不要使用这个选项，因为这样并没有解决任何问题，只是推迟了错误出现的时间，错误信息也变成了我们更熟悉的 <strong><font color="red">java.lang.OutOfMemoryError: Java heap space</font></strong> 而已。</p><p>另一个解决方案，如果你的应用程序确实内存不足，增加堆内存会解决<strong>GC overhead limit</strong>问题，就如下面这样，给应用程序1G的堆内存：</p><pre><code>java -Xmx1024m com.PackageName.ClassName</code></pre><p>但如果你想确保你已经解决了潜在的问题，而不是掩盖 <strong><font color="red">java.lang.OutOfMemoryError: GC overhead limit exceeded</font></strong> 错误，那么你不应该仅止步于此。你要记得还有<strong>profilers</strong>和<strong>memory dump analyzers</strong>这些工具，你需要花费更多的时间和精力来查找问题。需要注意的是，这些工具在Java运行时有显著的开销，因此不建议在生产环境中使用。</p><p>在生产环境中遇到了这个问题，在不知道原因时不要简单的猜测和规避。可以通过 <strong>-verbose:gc -XX:+PrintGCDetails</strong> 看下到底什么原因造成了异常。通常原因都是因为<strong>老年代区</strong>占用过多导致频繁<strong>Full GC</strong>，最终导致<strong>GC overhead limit exceed</strong>。如果gc log不够可以借助于JProfile等工具查看内存的占用，<strong>老年代区</strong>是否有内存泄露。分析内存泄露还有一个方法 <strong>-XX:+HeapDumpOnOutOfMemoryError</strong>，这样OOM时会自动做<strong>Heap Dump</strong>，可以拿<strong>MAT</strong>来排查了。还要留意<strong>新生代区</strong>，如果有过多短暂对象分配，可能也会抛这个异常。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> OOM </tag>
            
            <tag> GCOverheadLimit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java OOM之元空间异常</title>
      <link href="/articles/java/oom-zhi-yuan-kong-jian-yi-chang.html"/>
      <url>/articles/java/oom-zhi-yuan-kong-jian-yi-chang.html</url>
      
        <content type="html"><![CDATA[<p>分析什么情况会导致元空间异常：<strong><font color="red">java.lang.OutOfMemoryError: Metaspace</font></strong> 出现，并提供示例代码的同时为您提供解决指南。</p><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>前文 <a href="http://blog.lvmaohai.cn/articles/java/oom-zhi-chi-jiu-dai-yi-chang.html">Java OOM之持久代异常</a> 已经提过，PermGen区域用于存储类的名称和字段，类的方法，方法的字节码，常量池，JIT优化等，但从 <strong>Java8</strong> 开始，Java 中的内存模型发生了重大变化：引入了称为 <strong><font color="red">Metaspace</font></strong> 的新内存区域，而删除了PermGen区域。请注意：不是简单的将 <strong><font color="red">PermGen</font></strong> 区所存储的内容直接移到 <strong><font color="red">Metaspace</font></strong> 区，PermGen区中的某些部分，已经移动到了普通堆里面。</p><p><img src="https://cdn.jsdelivr.net/gh/lvmaohai/blog/images/article/java-oom-03.png" alt=""></p><p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：<font color="red">元空间并不在虚拟机中，而是使用本地内存。</font>因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小： </p><ul><li><p><strong><font color="red">-XX:MetaspaceSize</font></strong> 设置初始化的 Metaspace 大小。</p><p>该值越大触发<strong>Metaspace GC</strong>的时机就越晚。随着GC的到来，虚拟机会根据实际情况调控Metaspace的大小，可能增加上限也可能降低。在默认情况下，这个值大小根据不同的平台在12M到20M浮动。</p><p>使用 <strong>java -XX:+PrintFlagsInitial</strong> 命令查看本机的初始化参数，<strong>-XX:Metaspacesize</strong>为：21810376B（大约20.8M）</p></li><li><p><strong><font color="red">-XX:MaxMetaspaceSize</font></strong>，设置 Metaspacesize 上限的大小，默认是没有限制的</p><p>这个参数用于限制<strong>Metaspace 增长</strong>的上限，防止因为某些情况导致<strong>Metaspace</strong>无限的使用本地内存，影响到其他程序。</p><p>在本机上该参数的默认值为：4294967295B（大约4096MB）。 </p></li><li><p><strong><font color="red">-XX:MinMetaspaceFreeRatio</font></strong></p><p>当进行过<strong>Metaspace GC</strong>之后，会计算当前<strong>Metaspace</strong>的空闲空间比，如果空闲比小于这个参数，那么虚拟机将增长<strong>Metaspace</strong>的大小。</p><p>设置该参数可以控制<strong>Metaspace</strong>的增长的速度，太小的值会导致<strong>Metaspace</strong>增长的缓慢，<strong>Metaspace</strong>的使用逐渐趋于饱和，可能会影响之后类的加载。而太大的值会导致<strong>Metaspace</strong>增长的过快，浪费内存。</p><p>在本机该参数的默认值为40，也就是40%。</p></li><li><p><strong><font color="red">-XX:MaxMetaspaceFreeRatio</font></strong></p><p>当进行过<strong>Metaspace GC</strong>之后， 会计算当前<strong>Metaspace</strong>的空闲空间比，如果空闲比大于这个参数，那么虚拟机会释放<strong>Metaspace</strong>的部分空间。</p><p>在本机该参数的默认值为70，也就是70%。</p></li><li><p><strong><font color="red">-XX:MinMetaspaceExpansion</font></strong> 设置 Metaspace 增长时的最小幅度。</p><p>在本机上该参数的默认值为340784B（大约330KB为）。</p></li><li><p><strong><font color="red">-XX:MaxMetaspaceExpansion</font></strong> 设置 Metaspace 增长时的最大幅度。</p><p>在本机上该参数的默认值为5452592B（大约为5MB）。</p></li></ul><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>Java8 做出如此改变的原因包括但不限于：</p><ul><li><p>应用程序所需要的<strong>PermGen区</strong>大小很难预测，设置太小会触发<strong>PermGen OutOfMemoryError</strong>错误，过度设置导致资源浪费。</p></li><li><p>提升GC性能，在 <strong>HotSpot</strong> 中的每个垃圾收集器需要专门的代码来处理存储在 <strong>PermGen</strong> 中的类的元数据信息。从 <strong>PermGen</strong> 分离类的元数据信息到 <strong>Metaspace</strong>，由于 <strong>Metaspace</strong> 的分配具有和 <strong>Java Heap</strong> 相同的地址空间，因此 <strong>Metaspace</strong> 和 <strong>Java Heap</strong> 可以无缝的管理，而且简化了 <strong>FullGC</strong> 的过程，以至将来可以并行的对元数据信息进行垃圾收集，而没有 <strong>GC</strong> 暂停。</p></li><li><p>支持进一步优化，比如：<strong>G1</strong> 并发类的卸载，也算为将来做准备吧。</p></li></ul><p>正如你所看到的，元空间大小的要求取决于加载的类的数量以及这种类声明的大小。 所以很容易看到 <strong><font color="red">java.lang.OutOfMemoryError: Metaspace</font></strong> 主要原因：太多的类或太大的类加载到元空间。</p><h2 id="场景示例"><a href="#场景示例" class="headerlink" title="场景示例"></a>场景示例</h2><p>正如上文中所解释的，元空间的使用与加载到JVM中的类的数量密切相关。</p><p>下面的代码是最简单的例子：</p><pre><code>import javassist.ClassPool;public class MetaspaceTest {    static ClassPool cp = ClassPool.getDefault();    public static void main(String[] args) throws Exception{        for (int i = 0; ; i++) {             Class c = cp.makeClass("eu.plumbr.demo.Generated" + i).toClass();            System.out.println(i);        }    }}</code></pre><p>程序运行中不停的生成新类，所有的这些类的定义将被加载到<strong>Metaspace</strong>区，直到空间被完全占用并且抛出 <strong><font color="red">java.lang.OutOfMemoryError: Metaspace</font></strong> 异常。</p><p>当使用 <font color="red">-XX：MaxMetaspaceSize=32m</font> 启动时，大约加载30000多个类时就会死机。</p><pre><code>3102331024Exception in thread "main" javassist.CannotCompileException: by java.lang.OutOfMemoryError: Metaspace    at javassist.ClassPool.toClass(ClassPool.java:1170)    at javassist.ClassPool.toClass(ClassPool.java:1113)    at javassist.ClassPool.toClass(ClassPool.java:1071)    at javassist.CtClass.toClass(CtClass.java:1275)    at com.phlicode.MetaspaceTest.main(MetaspaceTest.java:12)    .....</code></pre><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>第一种解决方案是显而易见的，既然应用程序会耗尽内存中的<strong>Metaspace</strong>区空间，那么应该增加其大小，更改启动配置增加如下参数：</p><pre><code>// 告诉JVM：Metaspace允许增长到512，然后才能抛出异常-XX：MaxMetaspaceSize = 512m</code></pre><p>第二种解决方案是删除此参数来完全解除对<strong>Metaspace</strong>大小的限制（默认是没有限制的）。默认情况下，对于64位服务器端JVM，<strong>MetaspaceSize</strong>默认大小是21M（初始限制值），一旦达到这个限制值，<strong>FullGC</strong>将被触发进行类卸载，并且这个限制值将会被重置，新的限制值依赖于<strong>Metaspace</strong>的剩余容量。如果没有足够空间被释放，这个限制值将会上升，反之亦然。在技术上<strong>Metaspace</strong>的尺寸可以增长到交换空间，而这个时候本地内存分配将会失败。</p><p>可以通过修改各种启动参数来“快速修复”这些内存溢出错误，但需要正确区分是否只是推迟或者隐藏了 <strong><font color="red">java.lang.OutOfMemoryError</font></strong> 的症状。如果应用程序确实存在内存泄漏或者本来就加载了一些不合理的类，那么所有这些配置都只是推迟问题出现的时间而已，实际也不会改善任何东西。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> OOM </tag>
            
            <tag> Metaspace </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java OOM之持久代异常</title>
      <link href="/articles/java/oom-zhi-chi-jiu-dai-yi-chang.html"/>
      <url>/articles/java/oom-zhi-chi-jiu-dai-yi-chang.html</url>
      
        <content type="html"><![CDATA[<p>分析什么情况会导致持久代空间异常：<strong><font color="red">java.lang.OutOfMemoryError: Permgen space</font></strong> 出现，并提供示例代码的同时为您提供解决指南。</p><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p><img src="https://cdn.jsdelivr.net/gh/lvmaohai/blog/images/article/java-oom-02.jpg" alt="JVM内存模型示意图"></p><p>Java 应用程序在启动时，会指定所需要的堆内存大小，它被分割成两个不同的区域：<font color="red">Heap Space（堆空间）</font> 和 <font color="red">Permgen Space（持久代空间 Permanent Generation）</font>：</p><p><img src="https://cdn.jsdelivr.net/gh/lvmaohai/blog/images/article/java-oom-01.png" alt=""></p><p>持久代空间的大小可以在 JVM（Java虚拟机）启动时，通过如下参数设置：</p><ul><li><strong><font color="red">-XX：PermSize</font></strong> 设置<strong>持久代</strong>初始值。</li><li><strong><font color="red">-XX：MaxPermSize</font></strong> 设置<strong>持久代</strong>最大值。</li></ul><p>如果没有显式设置，则将使用特定平台的默认值。</p><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>要理解 <strong><font color="red">java.lang.OutOfMemoryError: PermGen space</font></strong> 出现的原因，首先需要理解 <strong>Permanent Generation</strong> 的用处是什么？</p><p>持久代主要存储的是每个类的信息，比如：类加载器引用、运行时常量池（所有常量、字段引用、方法引用、属性）、字段(Field)数据、方法(Method)数据、方法代码、方法字节码等等。<strong>PermGen</strong> 的大小取决于被加载类的数量以及类的大小。</p><p>因此，我们可以得出：<strong><font color="red">java.lang.OutOfMemoryError: PermGen space</font></strong> 异常的原因是：太多的类或者太大的类被加载到 <strong>permanent generation（持久代）</strong>，导致持久代所在区域的内存已被耗尽。</p><h2 id="场景示例"><a href="#场景示例" class="headerlink" title="场景示例"></a>场景示例</h2><p>① 最简单的示例</p><p>正如前面所描述的，PermGen的使用与加载到JVM类的数量有密切关系，下面是一个最简单的示例：</p><pre><code>import javassist.ClassPool;public class MicroGenerator {    public static void main(String[] args) throws Exception {        for (int i = 0; i &lt; 100_000_000; i++) {            generate("cn.moondev.User" + i);        }    }    public static Class generate(String name) throws Exception {        ClassPool pool = ClassPool.getDefault();        return pool.makeClass(name).toClass();    }}</code></pre><p>运行时请设置JVM参数：<strong><font color="red">-XX:MaxPermSize=5m</font></strong>，值越小越好。需要注意的是JDK8已经完全移除持久代空间，取而代之的是元空间（<strong><font color="red">Metaspace</font></strong>），所以示例最好的JDK1.7下运行。</p><p>代码在运行时不停的生成类并加载到持久代中，直到撑满持久代内存空间，最后抛出 <strong><font color="red">java.lang.OutOfMemoryError: PermGen space</font></strong> 异常。代码中类的生成使用了 <strong>javassist</strong> 库。</p><p>② Redeploy-time</p><p>更复杂和实际的一个例子就是 <strong>Redeploy</strong>（重新部署，可以想象一下开发时，使用idea时按ctrl + F5时的过程）。</p><p>在从服务器卸载应用程序时，当前的 <strong>classloader</strong> 以及 <strong>加载的class</strong> 在没有实例引用的情况下，持久代的内存空间会被 <strong>GC</strong> 清理并回收。如果应用中有 <strong>类的实例</strong> 对当前的 <strong>classloader</strong> 的引用，那么 <strong>Permgen区</strong> 的 <strong>class</strong> 将无法被卸载，导致 <strong>Permgen区</strong> 的内存一直增加直到出现 <strong>Permgen space</strong> 错误。</p><p>不幸的是，许多第三方库以及糟糕的资源处理方式（比如：线程、JDBC驱动程序、文件系统句柄）使得卸载以前使用的类加载器变成了一件不可能的事。反过来就意味着在每次重新部署过程中，应用程序所有的类的先前版本将仍然驻留在 <strong>Permgen区</strong> 中，你的每次部署都将生成几十甚至几百M的垃圾。</p><p>就以线程和JDBC驱动来说说。很多人都会使用线程来处理一下周期性或者耗时较长的任务，这个时候一定要注意线程的生命周期问题，你需要确保线程不能比你的应用程序活得还长。否则，如果应用程序已经被卸载，线程还在继续运行，这个线程通常会维持对应用程序的 <strong>classloader</strong> 的引用，造成的结果就不再多说。多说一句，开发者有责任处理好这个问题，特别是如果你是第三方库的提供者的话，一定要提供线程关闭接口来处理清理工作。</p><p>让我们想象一个使用JDBC驱动程序连接到关系数据库的示例应用程序。当应用程序部署到服务器上的时：服务器创建一个 <strong>classloader</strong> 实例来加载应用所有的类（包含相应的JDBC驱动）。根据JDBC规范，JDBC驱动程序（比如：com.mysql.jdbc.Driver）会在初始化时将自己注册到java.sql.DriverManager中。该注册过程中会将驱动程序的一个实例存储在DriverManager的静态字段内，代码可以参考：</p><pre><code>// com.mysql.jdbc.Driver源码package com.mysql.jdbc;public class Driver extends NonRegisteringDriver implements java.sql.Driver {    public Driver() throws SQLException {    }    static {        try {            DriverManager.registerDriver(new Driver());        } catch (SQLException var1) {            throw new RuntimeException("Can\'t register driver!");        }    }}// 再看下DriverManager对应代码private final static CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = new CopyOnWriteArrayList&lt;&gt;();public static synchronized void registerDriver(java.sql.Driver driver,DriverAction da) throws SQLException {    if(driver != null) {        registeredDrivers.addIfAbsent(new DriverInfo(driver, da));    } else {        throw new NullPointerException();    }}</code></pre><p>现在，当从服务器上卸载应用程序的时候，<strong><font color="red">java.sql.DriverManager</font></strong> 仍将持有那个驱动程序的引用，进而持有用于加载应用程序的 <strong>classloader</strong> 的一个实例的引用。这个 <strong>classloader</strong> 现在仍然引用着应用程序的所有类。如果此程序启动时需要加载2000个类，占用约10MB永久代（PermGen）内存，那么只需要5~10次重新部署，就会将默认大小的永久代（PermGen）塞满，然后就会触发 <strong><font color="red">java.lang.OutOfMemoryError: PermGen space</font></strong> 错误并崩溃。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>① 解决初始化时的 <strong>OutOfMemoryError</strong></p><p>当在应用程序启动期间，需要加载所有的类到 <strong>PermGen区域</strong> ，而触发由于 <strong>PermGen 耗尽</strong> 引起的 <strong>OutOfMemoryError</strong> 时，我们只需要增加它的大小。 </p><p>为此，请更改应用程序启动配置，并添加（或增加，如果存在）-XX：MaxPermSize参数，类似以下示例：</p><pre><code>$ java -XX:MaxPermSize=512m PackageName.ClassName</code></pre><p>② 解决 <strong>Redeploy</strong> 时的 <strong>OutOfMemoryError</strong></p><p>如果是你自己代码的问题请及时修改，如果是第三方库，请试着搜索一下是否存在”关闭”接口，如果没有给开发者提交一个bug或者issue吧。</p><p>③ 解决运行时 <strong>OutOfMemoryError</strong></p><p>首先，需要检查是否允许 <strong><font color="red">GC</font></strong> 从 <strong><font color="red">PermGen</font></strong> 卸载类，JVM 的标准配置相当保守，只要类一创建，即使已经没有实例引用它们，其仍将保留在内存中，特别是当应用程序需要动态创建大量的类但其生命周期并不长时，允许 JVM 卸载类对应用大有助益，可以通过在启动脚本中添加以下配置参数来实现：</p><pre><code>-XX:+CMSClassUnloadingEnabled</code></pre><p>默认情况下，这个配置是未启用的，如果启用它，<strong><font color="red">GC</font></strong> 将扫描 <strong><font color="red">PermGen</font></strong> 区并清理已经不再使用的类。但请注意，这个配置只在 <strong><font color="red">UseConcMarkSweepGC</font></strong> 的情况下生效，如果你使用其他 <strong>GC算法</strong>，比如：<strong>ParallelGC</strong> 或者 <strong>Serial GC</strong> 时，这个配置无效。所以使用以上配置时，请配合：</p><pre><code>-XX:+UseConcMarkSweepGC</code></pre><p>如果已经确保 JVM 可以卸载类，但是仍然出现内存溢出问题，那么应该继续分析 <strong><font color="red">dump文件</font></strong>，使用以下命令生成dump文件：</p><pre><code>jmap -dump:file=dump.hprof,format=b &lt;process-id&gt;</code></pre><p>当你拿到生成的堆转储文件，并利用像 <strong>Eclipse Memory Analyzer Toolkit</strong> 这样的工具来寻找应该卸载却没被卸载的类加载器，然后对该类加载器加载的类进行排查，找到可疑对象，分析使用或者生成这些类的代码，查找产生问题的根源并解决它。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> OOM </tag>
            
            <tag> PermgenSpace </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java OOM之堆空间异常</title>
      <link href="/articles/java/oom-zhi-dui-kong-jian-yi-chang.html"/>
      <url>/articles/java/oom-zhi-dui-kong-jian-yi-chang.html</url>
      
        <content type="html"><![CDATA[<p>分析什么情况会导致堆空间异常：<strong><font color="red">java.lang.OutOfMemoryError: Java heap space</font></strong> 出现，并提供示例代码的同时为您提供解决指南。</p><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p><img src="https://cdn.jsdelivr.net/gh/lvmaohai/blog/images/article/java-oom-02.jpg" alt="JVM内存模型示意图"></p><p>Java 应用程序在启动时，会指定所需要的堆内存大小，它被分割成两个不同的区域：<font color="red">Heap Space（堆空间）</font> 和 <font color="red">Permgen Space（持久代空间 Permanent Generation）</font>：</p><p><img src="https://cdn.jsdelivr.net/gh/lvmaohai/blog/images/article/java-oom-01.png" alt=""></p><p>Java中堆空间是 JVM 管理的最大一块内存空间，其中堆被划分成两个不同的区域：新生代（Young）和老年代（Tenured），新生代又被划分为3个区域：<strong><font color="red">Eden、From Survivor、To Survivor。</font></strong></p><p>堆空间的大小可以在 JVM（Java虚拟机）启动时，通过如下参数设置：</p><ul><li><p><strong><font color="red">-Xmx</font></strong> 设置 JVM 最大堆空间。</p></li><li><p><strong><font color="red">-Xms</font></strong> 设置 JVM 初始堆空间。</p><p>此值可以设置与 <strong>-Xmx</strong> 相同，以避免每次垃圾回收完成后JVM重新分配内存。</p></li><li><p><strong><font color="red">-Xmn</font></strong>：设置年轻代。</p><p>在整个堆堆空间大小确定的情况下，增大年轻代将会减小年老代，反之亦然，此值关系到JVM垃圾回收，对系统性能影响较大，<strong><font color="red">官方推荐配置为整个堆大小的3/8</font></strong>。</p></li></ul><p>如果没有显式设置，则将使用特定平台的默认值。</p><p>当应用程序试图向堆空间添加更多的数据，但堆却没有足够的空间来容纳这些数据时，将会触发 <strong><font color="red">java.lang.OutOfMemoryError: Java heap space</font></strong> 异常。需要注意的是： <font color="red">即使有足够的物理内存可用，只要达到堆空间设置的大小限制，此异常仍然会被触发。</font></p><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>触发 <strong><font color="red">java.lang.OutOfMemoryError: Java heap space</font></strong> 最常见的原因就是应用程序需要的堆空间是XXL号的，但是JVM提供的却是S号。解决方法也很简单，提供更大的堆空间即可。</p><p>除了前面的因素还有更复杂的成因：</p><ul><li><strong>流量/数据量峰值：</strong> 应用程序在设计之初均有用户量和数据量的限制，某一时刻，当用户数量或数据量突然达到一个峰值，并且这个峰值已经超过了设计之初预期的阈值，那么以前正常的功能将会停止，并触发 <strong><font color="red">java.lang.OutOfMemoryError: Java heap space</font></strong> 异常。</li><li><strong>内存泄漏：</strong> 特定的编程错误会导致你的应用程序不停的消耗更多的内存，每次使用有内存泄漏风险的功能就会留下一些不能被回收的对象到堆空间中，随着时间的推移，泄漏的对象会消耗所有的堆空间，最终触发 <strong><font color="red">java.lang.OutOfMemoryError: Java heap space</font></strong> 异常。</li></ul><h2 id="场景示例"><a href="#场景示例" class="headerlink" title="场景示例"></a>场景示例</h2><p>① 堆空间运行时设置不合理示例</p><p>下面的代码试图创建 2 x 1024 x 1024 个元素的整型数组，当你尝试编译并指定 <strong>12M 堆空间</strong> 运行时（java -Xmx12m OOMTest），将会失败并抛出 <strong><font color="red">java.lang.OutOfMemoryError: Java heap space</font></strong> 异常，而当你指定 <strong>13M 堆空间</strong> 时，将正常的运行。</p><pre><code>class OOMTest {    static final int SIZE = 2*1024*1024;    public static void main(String[] a) {        int[] i = new int[SIZE];    }}</code></pre><p>运行如下：</p><pre><code>$ javac OOMTest.java$ java -Xmx12m OOMTestException in thread "main" java.lang.OutOfMemoryError: Java heap space    at OOMTest.main(OOMTest.java:6)$ java -Xmx13m OOMTest</code></pre><p>② 程序内存泄漏示例</p><p>在Java中，当开发者创建一个新对象（比如：new Integer(5)）时，不需要自己开辟内存空间，而是把它交给JVM。在应用程序整个生命周期内，JVM负责检查哪些对象可用，哪些对象未被使用。未使用对象将被丢弃，其占用的内存也将被回收，这一过程被称为垃圾回收。JVM负责垃圾回收的模块集合被称为垃圾回收器（GC）。</p><p>Java的内存自动管理机制依赖于GC定期查找未使用对象并删除它们。Java中的内存泄漏是由于GC无法识别一些已经不再使用的对象，而这些未使用的对象一直留在堆空间中，这种堆积最终会导致 <strong><font color="red">java.lang.OutOfMemoryError: Java heap space</font></strong> 异常。</p><p>我们可以非常容易的写出导致内存泄漏的Java代码：</p><pre><code>public class KeylessEntry {    static class Key {        Integer id;        Key(Integer id) {            this.id = id;        }        @Override        public int hashCode() {            return id.hashCode();        }    }    public static void main(String[] args) {        Map&lt;Key,String&gt; m = new HashMap&lt;&gt;();        while(true) {            for(int i = 0; i &lt; 10000; i++) {                if(!m.containsKey(new Key(i))) {                    m.put(new Key(i), "Number:" + i);                }            }        }    }}</code></pre><p>代码中 <strong>HashMap</strong> 为本地缓存，第一次while循环，会将10000个元素添加到缓存中。后面的while循环中，由于key已经存在于缓存中，缓存的大小将一直会维持在10000。但事实真的如此吗？由于 <strong>Key 实体</strong> 没有实现 <strong>equals()</strong> 方法，导致for循环中每次执行 <strong>m.containsKey(new Key(i))</strong> 结果均为false，其结果就是HashMap中的元素将一直增加。</p><p>随着时间的推移，越来越多的 <strong>Key 对象</strong> 进入堆空间且不能被垃圾收集器回收（m为局部变量，GC会认为这些对象一直可用，所以不会回收），直到所有的堆空间被占用，最后抛出 <strong><font color="red">java.lang.OutOfMemoryError: Java heap space</font></strong> 异常。</p><blockquote><p>上面的代码直接运行可能很久也不会抛出异常，可以在启动时使用-Xmx参数，设置堆内存大小，或者在for循环后打印HashMap的大小，执行后会发现HashMap的size一直再增长。</p></blockquote><p>解决方法也非常简单，只要 <strong>Key</strong> 实现自己的 <strong>equals</strong> 方法即可：</p><pre><code>Overridepublic boolean equals(Object o) {    boolean response = false;    if (o instanceof Key) {        response = (((Key)o).id).equals(this.id);    }    return response;}</code></pre><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>先要确保有 <strong>足够的堆空间</strong> 来正常运行你的应用程序，在JVM的启动配置中分配 <strong>1024M堆空间</strong>，如下配置：</p><pre><code>-Xmx1024m</code></pre><p>当然也可以使用其他单位，比如用G表示GB，K表示KB。下面的示例都表示最大堆空间为1GB：</p><pre><code>java -Xmx1073741824 com.mycompany.MyClassjava -Xmx1048576k com.mycompany.MyClassjava -Xmx1024m com.mycompany.MyClassjava -Xmx1g com.mycompany.MyClass</code></pre><p>然后，更多的时候，单纯地增加堆空间不能解决所有的问题。如果你的程序存在内存泄漏，一味的增加堆空间也只是推迟 <strong><font color="red">java.lang.OutOfMemoryError: Java heap space</font></strong> 异常出现的时间而已，并未解决这个隐患。除此之外，垃圾收集器在GC时，应用程序会停止运行直到GC完成，而增加堆空间也会导致GC时间延长，进而影响程序的吞吐量。</p><p>如果你想完全解决这个问题，那就好好提升自己的编程技能吧，当然运用好 <strong>Debuggers, profilers, heap dump analyzers</strong> 等工具，可以让你的程序最大程度的避免内存泄漏问题。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> OOM </tag>
            
            <tag> HeapSpace </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8 - 函数式编程之Stream</title>
      <link href="/articles/java/han-shu-shi-bian-cheng-zhi-stream.html"/>
      <url>/articles/java/han-shu-shi-bian-cheng-zhi-stream.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Stream"><a href="#什么是Stream" class="headerlink" title="什么是Stream"></a>什么是Stream</h2><p>Stream API 借助于 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。通常编写并行代码很难而且容易出错, 但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。</p><p>流主要有三部分构成：获取一个数据源（source）→ 数据转换 → 执行操作获取想要的结果。每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道。</p><p><img src="https://cdn.jsdelivr.net/gh/lvmaohai/blog/images/article/java-stream-01.jpg" alt=""></p><h2 id="Stream的特点"><a href="#Stream的特点" class="headerlink" title="Stream的特点"></a>Stream的特点</h2><ul><li><p><strong>无存储性</strong></p><p>流不是存储元素的数据结构；相反，它需要从数据结构，数组，生成器函数或IO管道中获取数据并通过流水线地(计算)操作对这些数据进行转换。</p></li><li><p><strong>函数式编程</strong></p><p>Stream上操作会产生一个新结果，而不会去修改原始数据。比如filter过滤操作它只会根据原始集合中将未被过滤掉的元素生成一个新的Stream，而不是真的去删除集合中的元素。</p></li><li><p><strong>惰性求值</strong></p><p>很多Stream操作(如filter,map,distinct等)都是惰性实现，这样做为了优化程序的计算。比如说，要从一串数字中找到第一个能被10整除的数，程序并不需要对这一串数字中的每个数字进行测试。流操作分为两种：中间操作(返回值仍为Stream，仍可执行操作)，终断操作(结束Stream操作)。中间操作都是惰性操作。</p></li><li><p><strong>无限数据处理</strong></p><p>集合的大小是有限的，但是流可以对无限的数据执行操作。比如可以使用limit或findFirst这样的操作让Stream操作在有限的时间内结束。</p></li><li><p><strong>一次性消费</strong></p><p>流只能使用(“消费”)一次，一旦调用终断操作，流就不能再次使用，必须重新创建一个流。就像迭代器一样，遍历一遍后，想要再次遍历需要重新创建一个迭代器。</p></li></ul><h2 id="Stream的源的构建"><a href="#Stream的源的构建" class="headerlink" title="Stream的源的构建"></a>Stream的源的构建</h2><p>有多种方式可以构建流：</p><ol><li><p>静态工厂</p><ul><li>Stream.of()</li><li>IntStream.of()</li><li>LongStream.of()</li><li>DoubleStream.of()</li></ul></li><li><p>Collection 和 Array</p><ul><li>Collection.stream()</li><li>Collection.parallelStream()</li><li>Arrays.stream(T array)</li></ul></li><li><p>字符流</p><ul><li>BufferdReader.lines()</li></ul></li><li><p>文件路径</p><ul><li>Files.walk()</li><li>Files.lines()</li><li>Files.find()</li></ul></li><li><p>其它</p><ul><li>Random.ints()</li><li>BitSet.stream()</li><li>Pattern.splitAsStream(java.lang.CharSequence)</li><li>JarFile.stream()</li></ul></li></ol><p>生成流的时候，除了可以生成串行流，也可以生成并行流，即并行处理流的操作。</p><pre><code>final List&lt;String&gt; strings = Arrays.asList("ab", "a", "abc", "b", "bc");//串行流long count1 = strings.stream()    .filter(s -&gt; {        System.out.println("thread:" + Thread.currentThread().getId());        return s.startsWith("a");    })    .count();System.out.println(count1);//并行流long count2 = strings.parallelStream()    .filter(s -&gt; {        System.out.println("thread:" + Thread.currentThread().getId());        return s.startsWith("a");    })    .count();System.out.println(count2);</code></pre><h2 id="Stream操作的分类"><a href="#Stream操作的分类" class="headerlink" title="Stream操作的分类"></a>Stream操作的分类</h2><table><thead><tr><th align="left">Stream操作</th><th align="left">操作分类</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">中间操作(Intermediate operations)</td><td align="left">无状态(Stateless)</td><td align="left">unordered(), filter(), map(), mapToInt(), mapToLong(), mapToDouble(), flatMap(), flatMapToInt(), flatMapToLong(), flatMapToDouble(), peek();</td></tr><tr><td align="left">中间操作(Intermediate operations)</td><td align="left">有状态(Stateful)</td><td align="left">distinct();  sorted();  limit(), skip()</td></tr><tr><td align="left">终断操作(Terminal operations)</td><td align="left">非短路操作</td><td align="left">forEach(), forEachOrdered(); reduce(), collect(), max(), min(), count(); toArray()</td></tr><tr><td align="left">终断操作(Terminal operations)</td><td align="left">短路操作(short-circuiting)</td><td align="left">anyMatch(), allMatch(), noneMatch(); findFirst(), findAny()</td></tr></tbody></table><ul><li><p><strong>中间操作</strong></p><p>返回一个新的Stream。中间操作都是惰性的，它们不会对数据源执行任何操作，仅仅是创建一个新的Stream。在终断操作执行之前，数据源的遍历不会开始。</p></li><li><p><strong>终断操作</strong></p><p>遍历流并生成结果或者副作用。执行完终断操作后，Stream就会被“消费”掉，如果想再次遍历数据源，则必须重新创建新的Stream。大多数情况下，终断操作的遍历都是即时的——在返回之前完成数据源的遍历和处理，只有iterator()和spliterator()不是，这两个方法用于提供额外的遍历功能——让开发者自己控制数据源的遍历以实现现有Stream操作中无法满足的操作(实际上现有的Stream操作基本能满足需求，所以这两个方法目前用的不多)。</p></li></ul><h2 id="Stream的操作"><a href="#Stream的操作" class="headerlink" title="Stream的操作"></a>Stream的操作</h2><h3 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h3><h4 id="有状态操作"><a href="#有状态操作" class="headerlink" title="有状态操作"></a>有状态操作</h4><ul><li><p><strong>map</strong></p><blockquote><p>使用传入的Function对象对Stream中的所有元素进行处理，返回的Stream对象中的元素为原元素处理后的结果。</p></blockquote><p>  <img src="https://cdn.jsdelivr.net/gh/lvmaohai/blog/images/article/java-stream-02.jpg" alt=""></p><pre><code>  // map，平方数  List&lt;Integer&gt; nums = Arrays.asList(1, 2, 3, 4);  Collection&lt;Integer&gt; squareNums = nums.stream()      .map(n -&gt; n * n)      .collect(Collectors.toList());  squareNums.forEach(integer -&gt; System.out.println(integer));</code></pre></li><li><p><strong>flatMap</strong></p><blockquote><p>map 生成的是个 1:1 映射，每个输入元素，都按照规则转换成为另外一个元素。flatMap，则是一对多映射关系的。</p></blockquote><p>  <img src="https://cdn.jsdelivr.net/gh/lvmaohai/md-images/article/java-stream-03.jpg" alt=""></p><pre><code>  Stream&lt;List&lt;Integer&gt;&gt; inputStream = Stream.of(          Arrays.asList(1),          Arrays.asList(2, 3),          Arrays.asList(4, 5, 6)  );  List&lt;Integer&gt; integerStream = inputStream      .flatMap(list -&gt; list.stream())      .map(n -&gt; n * n)      .collect(Collectors.toList());  integerStream.forEach(System.out::println);</code></pre></li><li><p><strong>filter</strong></p><blockquote><p>filter 对原始 Stream 进行某项测试，通过测试的元素被留下来生成一个新 Stream</p></blockquote><p>  <img src="https://cdn.jsdelivr.net/gh/lvmaohai/blog/images/article/java-stream-04.jpg" alt=""></p><pre><code>  List&lt;String&gt; strings = Arrays.asList("ab", "a", "abc", "b", "bc");  strings.stream()      .filter(s -&gt; s.startsWith("a"))      .forEach(System.out::println);</code></pre></li><li><p><strong>peek</strong></p><blockquote><p>peek，遍历Stream中的元素，和forEach类似，区别是peek不会“消费”掉Stream，而forEach会消费掉Stream；peek是中间操作所以也是惰性的，只有在Stream“消费”的时候生效。</p></blockquote><pre><code>  // peek  Stream.of("one", "two", "three", "four")      .peek(e -&gt; System.out.println("原来的值: " + e))      .map(String::toUpperCase)      .peek(e -&gt; System.out.println("转换后的值: " + e))      .collect(Collectors.toList());</code></pre></li><li><p><strong>limit 和 skip</strong></p><blockquote><p>limit取头部的数据(或者说截取前面的元素)<br>skip取尾部的数据(跳过前面的元素)</p></blockquote><p>  <img src="https://cdn.jsdelivr.net/gh/lvmaohai/blog/images/article/java-stream-05.jpg" alt=""></p><pre><code>  //limit, 返回 Stream 的前面 n 个元素  List&lt;String&gt; strings = Arrays.asList("ab", "a", "abc", "b", "bc");  strings.stream()      .limit(3)      .forEach(System.out::println);  System.out.println("==============");  //skip 则是扔掉前 n 个元素  strings.stream()      .skip(3)      .forEach(System.out::println);</code></pre></li></ul><h4 id="无状态操作"><a href="#无状态操作" class="headerlink" title="无状态操作"></a>无状态操作</h4><ul><li><p><strong>distinct</strong></p><blockquote><p>去除重复的元素</p></blockquote><p>  <img src="https://cdn.jsdelivr.net/gh/lvmaohai/blog/images/article/java-stream-06.jpg" alt=""></p><pre><code>  Stream&lt;String&gt; distinctString = Stream.of("a","b","b","c")      .distinct();  distinctString.forEach(System.out::println);</code></pre></li><li><p><strong>sorted</strong></p><blockquote><p>对Stream中的元素进行排序。<br>有两个重载方法，其中 Stream&lt;T&gt; sorted() 需要元素实现了Comparable接口。</p></blockquote><pre><code>  Arrays.asList("ab", "a", "abc", "b", "bc").stream()      .sorted()      .forEach(System.out::println);  Arrays.asList("ab", "a", "abc", "b", "bc").stream()      .sorted((o1, o2) -&gt; {          return o1.compareTo(o2);      })      .forEach(System.out::println);</code></pre></li></ul><h3 id="终端操作"><a href="#终端操作" class="headerlink" title="终端操作"></a>终端操作</h3><h4 id="短路操作"><a href="#短路操作" class="headerlink" title="短路操作"></a>短路操作</h4><p>短路操作其实就和我们日常编程用到的&amp;&amp;和||运算符处理过程类似，遇到一个满足条件的就立即停止判断。</p><ul><li><p><strong>anyMatch</strong></p><blockquote><p>只要其中有一个元素满足传入的Predicate时返回True，否则返回False。<br>前面的中间操作只要anyMatch中的条件成立后，就不再执行。与逻辑运算符 || 类似。</p></blockquote><pre><code>  boolean anyMatchReturn = Arrays.asList("ab", "a", "abc", "b", "bc").stream()      .peek(s -&gt; System.out.println(s))      .anyMatch(s -&gt; s.startsWith("b"));  System.out.println(anyMatchReturn);</code></pre><p>  运行结果:</p><pre><code>  ab  a  abc  b  true</code></pre></li><li><p><strong>allMatch</strong></p><blockquote><p>所有元素均满足传入的Predicate时返回True，否则False。<br>只要allMatch条件有一个为false，中间操作将终止执行。与逻辑运算符&amp;&amp;类似</p></blockquote><pre><code>  boolean allMatchReturn = Arrays.asList("ab", "a", "abc", "b", "bc").stream()  .peek(s -&gt; System.out.println(s))  .allMatch(s -&gt; s.startsWith("b"));  System.out.println(allMatchReturn);</code></pre><p>  运行结果:</p><pre><code>  ab  false</code></pre></li><li><p><strong>noneMatch</strong></p><blockquote><p>所有元素均不满足传入的Predicate时返回True，否则False。<br>只要allMatch条件有一个为true，中间操作将终止执行。</p></blockquote><pre><code>  boolean noneMatchReturn = Arrays.asList("ab", "a", "abc", "b", "bc").stream()      .peek(s -&gt; System.out.println(s))      .noneMatch(s -&gt; s.startsWith("b"));  System.out.println(noneMatchReturn);</code></pre><p>  运行结果:</p><pre><code>  ab  a  abc  b  false</code></pre></li></ul><h4 id="非短路操作"><a href="#非短路操作" class="headerlink" title="非短路操作"></a>非短路操作</h4><ul><li><p><strong>forEach</strong></p><blockquote><p>对所有元素进行迭代处理，无返回值</p></blockquote><pre><code>  Arrays.asList("ab", "a", "abc", "b", "bc")      .forEach(System.out::println);</code></pre></li><li><p><strong>reduce</strong></p><blockquote><p>计算机术语规约，通过累加器accumulator，对前面的序列进行累计操作，并最终返回一个值。<br>累加器accumulator有两个参数，第一个是前一次累加的结果，第二个是前面集合的下一个元素。<br>通过reduce，可以实现 average, sum, min, max, count。</p></blockquote><p>  reduce 有三个重载方法：</p><ol><li><p><strong>T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</strong></p><blockquote><p>这里的identity是初始值。</p></blockquote><p>下面将会把几个字符组装成一个字符串</p><pre><code> String concat = Stream.of("A", "B", "C", "D")     .reduce("H", (x, y) -&gt; {         System.out.println("x=" + x + ", y=" + y);         return x.concat(y);     }); System.out.println(concat);</code></pre><p> 输出结果：</p><pre><code> x=H, y=A x=HA, y=B x=HAB, y=C x=HABC, y=D HABCD</code></pre></li><li><p><strong>Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)</strong></p><blockquote><p>由于没有初始值，这里输出Optional类型，避免空指针</p></blockquote><pre><code> Optional&lt;String&gt; concat2Optional = Stream.of("A", "B", "C", "D").reduce((x, y) -&gt; {     System.out.println("x=" + x + ", y=" + y);     return x.concat(y); }); System.out.println(concat2Optional.orElse("default"));</code></pre><p> 输出结果：</p><pre><code> x=A, y=B x=AB, y=C x=ABC, y=D ABCD</code></pre></li><li><p><strong>&lt;U&gt; U reduce(U identity, BiFunction&lt;U, ? super T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)</strong></p><blockquote><p>这个方法非常复杂，下次再细讲</p></blockquote></li></ol></li><li><p><strong>collect</strong></p><blockquote><p>collect方法可以通过收集器collector将流转化为其他形式，比如字符串、list、set、map。</p></blockquote><p>  collect有两个重载方法，其中一个是最常用的：</p><p>  <strong>&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector)</strong></p><p>  官方为了我们转换方便，已经在Collectors类中封装了各种各样的collector，下面看一些常用的收集器。</p><p>  <strong><em>拼接字符串</em></strong></p><pre><code>  String collect1 = Stream.of("A", "B", "C", "D")  .collect(Collectors.joining());  System.out.println(collect1);</code></pre><p>  <strong><em>转成List</em></strong></p><pre><code>  List&lt;String&gt; collect2 = Stream.of("A", "B", "C", "D")  .collect(Collectors.toList());</code></pre><p>  <strong><em>转成set</em></strong></p><pre><code>  Set&lt;String&gt; collect3 = Stream.of("A", "B", "C", "D")  .collect(Collectors.toSet());</code></pre><p>  <strong><em>转成map</em></strong></p><p>  Collectors的toMap方法签名如下所示，前一个mapper转换成map中的key,后一个mapper转换成map中的value</p><pre><code>  Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(  Function&lt;? super T, ? extends K&gt; keyMapper,   Function&lt;? super T, ? extends U&gt; valueMapper  )  Map&lt;String, String&gt; collect3 = Stream.of("A", "B", "C", "D")  .collect(Collectors.toMap(      s -&gt; s,      s -&gt; s  ));</code></pre></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 函数式编程 </tag>
            
            <tag> Stream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8 - 函数式编程之Optional</title>
      <link href="/articles/java/han-shu-shi-bian-cheng-zhi-optional.html"/>
      <url>/articles/java/han-shu-shi-bian-cheng-zhi-optional.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在某些情况下，首先要判断某个参数或者某个方法的返回值是否为null，才能继续操作该参数。</p><p>对于某些链式操作需要多次通过if语句判断是否为空，才能确保不抛出NullPointerException，这段非空判断的代码显得非常冗长和恶心。比如下面这段代码：</p><pre><code>String isoCode = "default";if (user != null) {    Address address = user.getAddress();    if (address != null) {        Country country = address.getCountry();        if (country != null) {            isocode = country.getIosCode();            if (isocode != null) {                isocode = isocode.toUpperCase();            }        }    }}</code></pre><p>在java 8里，JDK引入了一个Optional类，该类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。通过本文的学习，我们看下如何通过Optional类重写上面那段判空代码。</p><h2 id="Optional初始化"><a href="#Optional初始化" class="headerlink" title="Optional初始化"></a>Optional初始化</h2><p>Optional类的构造方法是私有方法，所以只能通过它的静态工厂方法进行初始化。它的初始化方法有如下几种：</p><ul><li><p><strong>&lt;T&gt; Optional&lt;T&gt; of(T value)</strong></p><blockquote><p>为非null的值创建一个Optional。如果传入参数为null，抛出NullPointerException。</p></blockquote><pre><code>  // 调用工厂方法创建Optional实例  Optional&lt;String&gt; name = Optional.of("hello");  // 传入参数为null，抛出NullPointerException.  Optional&lt;String&gt; someNull = Optional.of(null);</code></pre></li><li><p><strong>&lt;T&gt; Optional&lt;T&gt; ofNullable(T value)</strong></p><blockquote><p>为指定的值创建一个Optional，如果指定的值为null，则返回一个空的Optional。<br>它和 of 的区别是可以传null值。</p></blockquote><pre><code>  // 调用工厂方法创建Optional实例  Optional&lt;String&gt; name = Optional.ofNullable("hello");  // 传入参数为null，不抛出NullPointerException，返回一个空的Optional.  Optional&lt;String&gt; someNull = Optional.ofNullable(null);</code></pre></li><li><p><strong>&lt;T&gt; Optional&lt;T&gt; empty()</strong></p><blockquote><p>是 ofNullable静态工厂方法，传null值时的实现，返回一个空的Optional。</p></blockquote><pre><code>  Optional empty = Optional.empty();</code></pre></li></ul><h2 id="Optional类的其它方法"><a href="#Optional类的其它方法" class="headerlink" title="Optional类的其它方法"></a>Optional类的其它方法</h2><ul><li><p><strong>boolean isPresent()</strong></p><blockquote><p>如果值存在返回true，否则返回false。</p></blockquote><pre><code>  // false  Optional&lt;String&gt; empty = Optional.ofNullable(null);  System.out.println(empty.isPresent());  // true  Optional&lt;String&gt; optionalS2 = Optional.of(s2);  System.out.println(optionalS2.isPresent());</code></pre></li><li><p><strong>T get()</strong></p><blockquote><p>如果Optional有值则将其返回，否则抛出NoSuchElementException</p></blockquote><pre><code>  // 获取hello  Optional.of("hello").get();  // 抛出NoSuchElementException  Optional.empty().get();</code></pre></li><li><p><strong>void ifPresent (Consumer&lt;? super T&gt; consumer)</strong></p><blockquote><p>如果Optional实例有值则调用consumer，否则不做处理。</p></blockquote><pre><code>  //调用ifPresent方法里面的consumer  Optional.of("hello")          .ifPresent(System.out::println);</code></pre></li><li><p><strong>T orElse(T other)</strong></p><blockquote><p>如果有值则将其返回，否则返回指定的其它值</p></blockquote><pre><code>  // 输出null  System.out.println(Optional.empty().orElse("null"));  // 输出hello  System.out.println(Optional.of("hello").orElse("null"));</code></pre></li><li><p><strong>T orElseGet (Supplier&lt;? extends T&gt; other)</strong></p><blockquote><p>orElseGet与orElse方法类似，区别在于得到的默认值。<br>orElse方法将传入的字符串作为默认值，<br>orElseGet方法可以接受 Supplier 接口的实现用来生成默认值。</p></blockquote><pre><code>  // 输出null  System.out.println(Optional.empty().orElseGet(() -&gt; "null"));  // 输出hello  System.out.println(Optional.of("hello").orElseGet(() -&gt; "null"));</code></pre></li><li><p><strong>&lt;X extends Throwable&gt; T orElseThrow (Supplier&lt;? extends X&gt; exceptionSupplier) throws X</strong></p><blockquote><p>如果有值则将其返回，否则抛出 supplier 接口创建的异常。</p></blockquote><pre><code>  // 抛出exception  try {      Optional.empty()              .orElseThrow(()-&gt;new Exception("为空"));  } catch (Exception e) {      e.printStackTrace();  }</code></pre></li><li><p><strong>&lt;U&gt; Optional&lt;U&gt; map (Function&lt;? super T, ? extends U&gt; mapper)</strong></p><blockquote><p>如果参数 mapper 有值，则调用map方法执行mapper参数的Function方法得到返回值。<br>如果mapper的返回值不为null，则创建包含mapping返回值的Optional作为map方法返回值，否则返回空Optional。<br>如果传入的mapper参数是null，抛出NullPointerException。</p></blockquote><pre><code>  // 输出 JACK  Optional&lt;String&gt; stringOptional = Optional.of("jack")      .map((value) -&gt; value.toUpperCase());  System.out.println(stringOptional.orElse("default"));  // 输出 default  Optional&lt;String&gt; stringOptional1 = Optional.of("jack")      .map((value) -&gt; null);  System.out.println(stringOptional1.orElse("default"));  // 输出 default，并且不会调用mapper  String s2 = null;  Optional&lt;String&gt; stringOptional2 = Optional.ofNullable(s2)      .map((value) -&gt; value.toUpperCase());  System.out.println(stringOptional2.orElse("default"));  // 如果参数mapper为null，抛NullPointerException异常  try {      String s3 = null;      Optional&lt;String&gt; stringOptional3 = Optional.ofNullable(s3)          .map(null);      System.out.println(stringOptional3.orElse("default"));  } catch (Exception e) {}</code></pre></li><li><p><strong>&lt;U&gt; Optional&lt;U&gt; flatMap (Function&lt;? super T, Optional&lt;U&gt;&gt; mapper)</strong></p><blockquote><p>flatMap与map方法类似，区别在于flatMap中的mapper返回值必须是Optional。调用结束时，flatMap不会对结果用Optional封装。</p></blockquote><pre><code>  // flatMap，输出 JACK  Optional&lt;String&gt; stringOptional4 = Optional.of("jack")      .flatMap(value -&gt; Optional.ofNullable(value.toUpperCase()));  System.out.println(stringOptional4.orElse("default"));  // flatMap，输出 default  Optional&lt;String&gt; stringOptional5 = Optional.of("jack")      .flatMap(value -&gt; Optional.ofNullable(null));  System.out.println(stringOptional5.orElse("default"));  // flatMap，输出 default，并且不会调用mapper  String s6 = null;  Optional&lt;String&gt; stringOptional6 = Optional.ofNullable(s6)      .flatMap(value -&gt; Optional.ofNullable(value.toUpperCase()));  System.out.println(stringOptional6.orElse("default"));  // flatMap 如果map的参数mapper为null，抛NullPointerException异常  try {      String s7 = null;      Optional&lt;String&gt; stringOptional7 = Optional.ofNullable(s7)          .flatMap(null);      System.out.println(stringOptional7.orElse("default"));  } catch (Exception e) {      System.out.println("出错了");  }</code></pre></li><li><p><strong>Optional&lt;T&gt; filter (Predicate&lt;? super T&gt; predicate)</strong></p><blockquote><p>如果有值并且满足断言条件返回包含该值的Optional，否则返回空Optional。</p></blockquote><pre><code>  // 输出default  String filterString = Optional.of("hugo")          .filter(s -&gt; "jack".equals(s))          .orElse("default");  System.out.println(filterString);  // 输出hugo  String filterString2 = Optional.of("hugo")          .filter(s -&gt; "hugo".equals(s))          .orElse("default");  System.out.println(filterString2);  // 输出default，断言接口里面的语句不会执行  String nullableString = null;  String filterString3 = Optional.ofNullable(nullableString)          .filter(s -&gt; {              System.out.println("测试是否调用");              return "jack".equals(s);          })          .orElse("default");  System.out.println(filterString3);</code></pre></li></ul><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>经过上面学习Optional的相关API，已经对它有了一定的了解。下面，我们运用上面的知识解决在前言中遗留的问题。</p><pre><code>ioscode = Optional.ofNullable(user)        .map(u -&gt; u.getAddress())        .map(addr -&gt; addr.getCountry())        .map(country -&gt; country.getIosCode())        .map(String::toUpperCase)        .orElse("default");</code></pre><p>从上面的学习可以知道，只有Optional是empty的，map方法不会被调用。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 函数式编程 </tag>
            
            <tag> Optional </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8 - 函数式编程之Lambda</title>
      <link href="/articles/java/han-shu-shi-bian-cheng-zhi-lambda.html"/>
      <url>/articles/java/han-shu-shi-bian-cheng-zhi-lambda.html</url>
      
        <content type="html"><![CDATA[<p>Lambda表达式是Java8的新语法糖。它其实是一个匿名函数，可以把Lambda表达式理解为一段约定好怎么传递参数和返回参数的一段代码，由编译器负责参数类型的猜测并执行结果。我们通过lambda表达式可以写出更简洁、更灵活的代码。</p><h2 id="Lambda-表达式语法"><a href="#Lambda-表达式语法" class="headerlink" title="Lambda 表达式语法"></a>Lambda 表达式语法</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><blockquote><p>“-&gt;” 操作符将 Lambda 表达式分为两个部分：左侧为参数列表，右侧为 Lambda 体。</p></blockquote><pre><code># Lambda 体，单行表达式，直接写在 “-&gt;” 右侧(parameters) -&gt; expression# Lambda 体，有多行表达式，用 “{}” 包含起来(parameters) -&gt; { statements; }</code></pre><h3 id="具体的语法"><a href="#具体的语法" class="headerlink" title="具体的语法"></a>具体的语法</h3><table><thead><tr><th align="left">场景</th><th align="left">案例</th></tr></thead><tbody><tr><td align="left">无参数，无返回值</td><td align="left">() -&gt; System.out.println(“Helo”);</td></tr><tr><td align="left">无参数，有返回值</td><td align="left">() -&gt; 10;</td></tr><tr><td align="left">有一个参数，无返回值</td><td align="left">x -&gt; System.out.print(x);</td></tr><tr><td align="left">有一个参数，有返回值</td><td align="left">x -&gt; x + 10;</td></tr><tr><td align="left">有多个参数，没有返回值</td><td align="left">(x, y) -&gt; System.out.println(x + y);</td></tr><tr><td align="left">有多个参数，有返回值</td><td align="left">(x, y) -&gt; x + y;</td></tr></tbody></table><p>其实，每个lambda表达式的返回值都是一个函数式编程的接口。</p><h2 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h2><ul><li><p>无参数，无返回值</p><pre><code>  Runnable runnable = () -&gt; System.out.println("hello");  new Thread(runnable).start();</code></pre></li><li><p>无参数，有返回值</p><pre><code>  Supplier&lt;Integer&gt; supplier = () -&gt; 10;  Integer number = supplier.get();  System.out.println(number);</code></pre></li><li><p>有一个参数，无返回值</p><pre><code>  Consumer&lt;String&gt; consumer = x -&gt; System.out.println(x);  or   Consumer&lt;String&gt; consumer = (x) -&gt; System.out.println(x);  or   Consumer&lt;String&gt; consumer = (x) -&gt; {      System.out.println(x);  };  consumer.accept("hello");</code></pre></li><li><p>有一个参数，有返回值</p><pre><code>  Function&lt;Integer,Integer&gt; function = x -&gt; x + 10;  or  Function&lt;Integer,Integer&gt; function = (x) -&gt; x + 10;  or  Function&lt;Integer, Integer&gt; function = (x) -&gt; {      return x + 10;  };  int result = function.apply(20);  System.out.println(result);</code></pre></li><li><p>多个参数，没有返回值</p><pre><code>  BiConsumer&lt;Integer, String&gt; consumer = (x, y) -&gt; {      System.out.println(x);      System.out.println(y);  };  or  BiConsumer&lt;Integer, String&gt; consumer = (Integer x, String y) -&gt; {      System.out.println(x);      System.out.println(y);  };  consumer.accept(100, "hello");</code></pre></li><li><p>多个参数，有返回值</p><pre><code>  BiFunction&lt;Integer, Integer, Integer&gt; function = (x, y) -&gt; x + y;  or  BiFunction&lt;Integer, Integer, Integer&gt; function = (Integer x, Integer y) -&gt; x + y;  or  BiFunction&lt;Integer, Integer, Integer&gt; function = (Integer x, Integer y) -&gt; {      return x + y;  };  int result = function.apply(10, 10);  System.out.println(result);</code></pre></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 函数式编程 </tag>
            
            <tag> Lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8 - 函数式编程之基本接口</title>
      <link href="/articles/java/han-shu-shi-bian-cheng-zhi-ji-ben-jie-kou.html"/>
      <url>/articles/java/han-shu-shi-bian-cheng-zhi-ji-ben-jie-kou.html</url>
      
        <content type="html"><![CDATA[<p>不管lambda表达式还是Stream流式编程，Function、Consumer、Supplier、Predicate 四个接口是一切函数式编程的基础。</p><p><img src="https://cdn.jsdelivr.net/gh/lvmaohai/blog/images/article/java-function-01.jpg" alt=""></p><ul><li>Supplier<t>：T get()；无输入，“生产”一个T类型的返回值。</t></li><li>Consumer<t>：void accept(T t)；输入类型T，“消费”掉，无返回。</t></li><li>Function&lt;T, R&gt;：R apply(T t)；输入类型T返回类型R。</li><li>Predicate<t>：boolean test(T t)；输入类型T，并进行条件“判断”，返回true|false。</t></li></ul><h2 id="interface-Supplier-lt-T-gt"><a href="#interface-Supplier-lt-T-gt" class="headerlink" title="interface Supplier<T>"></a>interface Supplier&lt;T&gt;</h2><blockquote><p>该接口的中文直译是“提供者”，可以理解为定义一个lambda表达式，没有输入参数，返回一个T类型的值。</p></blockquote><pre><code>Supplier&lt;Integer&gt; supplier = () -&gt; 10;// 输出10System.out.println(supplier.get());</code></pre><h2 id="interface-Consumer-lt-T-gt"><a href="#interface-Consumer-lt-T-gt" class="headerlink" title="interface Consumer<T>"></a>interface Consumer&lt;T&gt;</h2><blockquote><p>该接口的中文直译是“消费”，可以理解为定义一个lambda表达式，接收一个T类型的参数，并且没有返回值。</p></blockquote><ul><li><p><strong>accept</strong> ：接收参数，并调用Consumer接口里的方法</p><pre><code>  Consumer&lt;Integer&gt; consumer = x -&gt; System.out.println(x);  // 输出10  consumer.accept(10);</code></pre></li><li><p><strong>andThen</strong>：调用完consumer自己后，还调用andThen方法参数中指定的Consumer</p><pre><code>  Consumer&lt;Integer&gt; consumer = x -&gt; System.out.println(x);  Consumer&lt;Integer&gt; plusSelf = x -&gt; System.out.println(x + x);  // 输出10以及20  consumer.andThen(plusSelf).accept(10);</code></pre></li></ul><h2 id="interface-Function-lt-T-R-gt"><a href="#interface-Function-lt-T-R-gt" class="headerlink" title="interface Function<T, R>"></a>interface Function&lt;T, R&gt;</h2><blockquote><p>该接口的中文直译是“函数”，可以理解为：定义一个lambda表达式，接收一个T类型的参数，返回一个R类型的值。</p></blockquote><ul><li><p><strong>apply</strong>：传入一个T类型的参数，返回一个R类型的值</p><pre><code>  Function&lt;Integer, Integer&gt; function = x -&gt; x + x;  // 输出20  System.out.println(function.apply(10));</code></pre></li><li><p><strong>compose</strong>：accept获取到的参数，先执行compose里面的Function，再执行原Function</p><pre><code>  Function&lt;Integer, Integer&gt; plusSelf = x -&gt; {      System.out.println("plusSelf");      return x + x;  };  Function&lt;Integer, String&gt; toString = x -&gt; {      System.out.println("toString");      return String.valueOf(x);  };  // 输出20，整数10先自加变成20，然后由toString转换成字符串  String string1 = toString.compose(plusSelf).apply(10);  System.out.println(string1);</code></pre></li><li><p><strong>andThen</strong>：与compose相反。先执行原Function，在执行andThen里面的Function。</p><pre><code>  Function&lt;Integer, Integer&gt; plusSelf = x -&gt; {      System.out.println("plusSelf");      return x + x;  };  Function&lt;Integer, String&gt; toString = x -&gt; {      System.out.println("toString");      return String.valueOf(x);  };  // 输出20, 先自加，再转换成字符串  String string2 = plusSelf.andThen(toString).apply(10);  System.out.println(string2);</code></pre></li></ul><h2 id="interface-Predicate-lt-T-gt"><a href="#interface-Predicate-lt-T-gt" class="headerlink" title="interface Predicate<T>"></a>interface Predicate&lt;T&gt;</h2><blockquote><p>该接口的中文直译是“断言”，用于返回false/true。T是lambda表达式的输入参数类型。</p></blockquote><ul><li><p><strong>test</strong>：测试test方法中输入参数是否满足接口中定义的lambda表达式</p><pre><code>  Predicate&lt;String&gt; test = x -&gt; "test".equals(x);  Predicate&lt;String&gt; test2 = x -&gt; "test2".equals(x);  // 输出 true  System.out.println(test.test("test"));  // 输出 false  System.out.println(test.test("test_false"));</code></pre></li><li><p><strong>and</strong>：原 Predicate 接口和 and 方法中指定的 Predicate 接口要同时为true，test方法才为true。与逻辑运算符 &amp;&amp; 一致。</p><pre><code>  Predicate&lt;String&gt; test = x -&gt; "test".equals(x);  Predicate&lt;String&gt; test2 = x -&gt; "test2".equals(x);  // 输出 false  System.out.println(test.and(test2).test("test"));</code></pre></li><li><p><strong>negate</strong>：对结果取反后再输出</p><pre><code>  Predicate&lt;String&gt; test = x -&gt; "test".equals(x);  Predicate&lt;String&gt; test2 = x -&gt; "test2".equals(x);  // 输出 false  System.out.println(test.negate().test("test"));</code></pre></li><li><p><strong>or</strong>：原 Predicate 接口和 or 方法中指定的 Predicate 接口只要一个为true，test方法为true。与逻辑运算符 || 一致。</p><pre><code>  Predicate&lt;String&gt; test = x -&gt; "test".equals(x);  Predicate&lt;String&gt; test2 = x -&gt; "test2".equals(x);  // 输出 false  System.out.println(test.or(test2).test("test"));</code></pre></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8 - 函数式编程之简介</title>
      <link href="/articles/java/han-shu-shi-bian-cheng-zhi-jian-jie.html"/>
      <url>/articles/java/han-shu-shi-bian-cheng-zhi-jian-jie.html</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>简单说，”函数式编程”是一种”编程范式”（programming paradigm），也就是如何编写程序的方法论。</p><p>它属于”结构化编程”的一种，主要思想是把运算过程尽量写成一系列嵌套的函数调用。举例来说，现在有这样一个数学表达式：</p><pre><code>(1 + 2) * 3 - 4</code></pre><p>传统的过程式编程，可能这样写：</p><pre><code>var a = 1 + 2;var b = a * 3;var c = b - 4;</code></pre><p>函数式编程要求使用函数，我们可以把运算过程定义为不同的函数，然后写成下面这样：</p><pre><code>var result = subtract(multiply(add(1,2), 3), 4);</code></pre><p>这就是函数式编程。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li><p>函数是”第一等公民”</p><p> 所谓”第一等公民”（first class），指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。</p><p> 举例来说，下面代码中的print变量就是一个函数，可以作为另一个函数的参数。</p><pre><code> var print = function(i) {    console.log(i); }; [1,2,3].forEach(print);</code></pre></li><li><p>只用”表达式”，不用”语句”</p><p> “表达式”（expression）是一个单纯的运算过程，总是有返回值；”语句”（statement）是执行某种操作，没有返回值。函数式编程要求，只使用表达式，不使用语句。也就是说，每一步都是单纯的运算，而且都有返回值。</p><p> 原因是函数式编程的开发动机，一开始就是为了处理运算（computation），不考虑系统的读写（I/O）。”语句”属于对系统的读写操作，所以就被排斥在外。</p><p> 当然，实际应用中，不做I/O是不可能的。因此，编程过程中，函数式编程只要求把I/O限制到最小，不要有不必要的读写行为，保持计算过程的单纯性。</p></li><li><p>没有”副作用”</p><p> 所谓”副作用”（side effect），指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。</p><p> 函数式编程强调没有”副作用”，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值.</p></li><li><p>不修改状态<br> 函数式编程只是返回新的值，不修改系统变量。</p><p> 在其他类型的语言中，变量往往用来保存”状态”（state）。不修改变量，意味着状态不能保存在变量中。函数式编程使用参数保存状态，最好的例子就是递归。</p></li><li><p>引用透明</p><p> 引用透明（Referential transparency），指的是函数的运行不依赖于外部变量或”状态”，只依赖于输入的参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的。</p><p> 其他类型的语言，函数的返回值往往与系统状态有关，不同的状态之下，返回值是不一样的。这就叫”引用不透明”，很不利于观察和理解程序的行为。</p></li></ol><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li><p>代码简洁，开发快速</p></li><li><p>接近自然语言，易于理解<br> (1+2)*3-4用函数式语言表达</p><pre><code> add(1,2).multiply(3).subtract(4)</code></pre></li><li><p>更方便的代码管理</p><p> 不依赖、也不会改变外界的状态，只要给定输入参数，返回的结果必定相同。因此，每一个函数都可以被看做独立单元，很有利于进行单元测试（unit testing）和除错（debugging），以及模块化组合。</p></li><li><p>易于”并发编程”<br> 函数式编程不需要考虑”死锁”（deadlock），因为它不修改变量，所以根本不存在”锁”线程的问题。不必担心一个线程的数据，被另一个线程修改，所以可以很放心地把工作分摊到多个线程，部署”并发编程”（concurrency）。</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>API通信协议规范</title>
      <link href="/articles/api-tong-xin-xie-yi-gui-fan.html"/>
      <url>/articles/api-tong-xin-xie-yi-gui-fan.html</url>
      
        <content type="html"><![CDATA[<h2 id="协议类型"><a href="#协议类型" class="headerlink" title="协议类型"></a>协议类型</h2><ul><li>支持 https、dubbo 协议；</li><li>面向用户的客户端与服务端的通信，使用 https 协议；</li><li>面向应用的内部服务之间的通信，使用 dubbo 协议；</li></ul><h2 id="版本定义"><a href="#版本定义" class="headerlink" title="版本定义"></a>版本定义</h2><blockquote><p>版本号是由（.）分隔的三组数字组成的（例如，1.13.2）； </p></blockquote><ul><li><p>第一组数字是主版本号。产品方向改变，或者大规模 API 不兼容，或者架构不兼容升级，提升主版本号；</p></li><li><p>第二组数字是次版本号。保持相对兼容性，增加主要功能特性，影响范围极小的 API 不兼容修改，提升次版本号；</p></li><li><p>第三组数字是修订版本号。保持完全兼容性，修复 BUG、新增次要功能特性等；</p></li></ul><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><blockquote><p>需要对 API 做版本兼容和合法性校验；</p></blockquote><ul><li><p>实际应用中存在同一个 API 有多个版本的情况，且多版本需要同时提供服务，客户端需要明确指定需要调用 API 的哪个版本（主版本号）。</p></li><li><p>客户端通过 API 透传给服务端的数据，为了防止被非法篡改，需要对数据进行数字签名，以确保数据的合法性（把参数的key/value，按一定规则进行加密）。</p></li><li><p>客户端发起的 API 请求，需要对客户端的身份做合法性校验，避免非法客户端恶意请求（对客户端进行注册登记，授权访问权限）</p></li><li><p>客户端每次发起的 API 请求，需要对请求频率的指标进行界定，并进行合理性限制（数字签名时，可以考虑加入客户端IP、发起请求的时间戳（毫秒）等参数）。</p></li></ul><h2 id="HTTP-请求方法"><a href="#HTTP-请求方法" class="headerlink" title="HTTP 请求方法"></a>HTTP 请求方法</h2><ul><li><strong>GET</strong> 查询资源（幂等）；</li><li><strong>POST</strong> 新建资源（非幂等）；</li><li><strong>PUT</strong> 全量更新资源（资源必须存在）（幂等）；</li><li><strong>PATCH</strong> 部分更新资源（资源存在时更新，不存在时创建）（非幂等）；</li><li><strong>DELETE</strong> 删除资源（幂等）；</li><li><strong>HEAD</strong> 与GET类似，但是HEAD并不返回消息体，通常用于检测资源的有效性、传递安全认证信息；</li></ul><blockquote><p>注意：通过标准HTTP方法对资源进行C(create)、R(read)、U(update)、D(delete)</p></blockquote><h2 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h2><blockquote><p>API 返回规范的 HTTP 状态码, 表示 API 调用结果。</p></blockquote><p>常用状态码如下:</p><h3 id="2xx"><a href="#2xx" class="headerlink" title="2xx"></a>2xx</h3><ul><li><strong>200</strong>: OK，GET 请求成功；DELETE, PATCH, PUT 请求成功，并且资源同步处理成功；</li><li><strong>201</strong>: Created，POST 请求成功，并且资源同步处理成功；</li><li><strong>202</strong>: Accepted，POST, PUT, PATCH, DELETE 请求成功，并且资源是异步处理的；</li><li><strong>204</strong>: No Content，请求成功, 但无需返回任何内容, 且禁止包含任何消息体；</li></ul><h3 id="3xx"><a href="#3xx" class="headerlink" title="3xx"></a>3xx</h3><ul><li><strong>301</strong>: Moved Permanently，客户请求的资源在其他地方，新的URL在Location头中给出，浏览器应该自动地访问新的URL；</li><li><strong>302</strong>: Found，客户请求的资源在其他地方，新的URL在Location头中给出，浏览器应该自动地访问新的URL，但新的URL应该被视为临时性的替代，而不是永久性的；</li><li><strong>304</strong>: Not Modified，客户端有缓冲的资源并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的资源还可以继续使用；</li></ul><h3 id="4xx"><a href="#4xx" class="headerlink" title="4xx"></a>4xx</h3><ul><li><strong>400</strong>: Bad Request，请求语义或参数有误，当前请求无法被服务器理解；除非进行修改，否则客户端不应该重复提交这个请求；</li><li><strong>401</strong>: Unauthorized，所访问的资源，需要身份认证；</li><li><strong>403</strong>: Forbidden，资源无权限访问；</li><li><strong>404</strong>: Not Found，无法找到指定位置的资源；</li><li><strong>405</strong>: Method Not Allowed，请求方法（GET、POST、PUT、PATCH、DELETE等）对指定的资源不适用；</li><li><strong>406</strong>: Not Acceptable，指定的资源已经找到，但它的MIME类型和客户端在Accpet头中所指定的不兼容；</li><li><strong>413</strong>: Request Entity Too Large，目标资源的大小超过服务器当前能处理的大小。</li><li><strong>429</strong>: Too Many Requests，因为访问频繁，你已经被限制访问，稍后重试；</li></ul><h3 id="5xx"><a href="#5xx" class="headerlink" title="5xx"></a>5xx</h3><ul><li><strong>500</strong>: Internal Server Error，服务器遇到了意料不到的情况，不能完成客户的请求；</li><li><strong>502</strong>: Bad Gateway，服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答；</li><li><strong>503</strong>: Service Unavaliable，服务器由于维护或者负载过重未能应答；</li><li><strong>504</strong>: Gateway Timeout，由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答；</li></ul><h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><h3 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h3><h4 id="headers"><a href="#headers" class="headerlink" title="headers"></a>headers</h4><ul><li><strong>认证信息（Authorization）</strong>：Bearer ACCESS_TOKEN;</li><li><strong>数据格式（Accept）</strong>：application/json;</li><li><strong>客户端信息（X-Client-Agent）</strong>: id=客户端ID;ip=客户端IP;version=客户端版本号;</li><li><strong>设备信息（X-Device-Agent）</strong>: id=设备ID;name=设备名称(Web|iOS|Android);</li><li><strong>API 信息（X-Api-Agent）</strong>: version=api版本号;timestamp=请求时间（毫秒）;sign=数字签名;</li><li><strong>请求ID（X-Request-ID）</strong>：每个请求中包含一个随机生成的 UUID 作为 Request-Id;</li></ul><h4 id="body"><a href="#body" class="headerlink" title="body"></a>body</h4><p>采用 json 格式（Content-Type: application/json），例如：</p><pre><code>{    "username":"Dipper",     "age": 21,     "is_admin": false}curl -X POST -d '{"username":"Dipper", "age": 21, "is_admin": false}' https://api.example.com/role</code></pre><p><font color="red">注意：保持数据结构简单，建议多层嵌套的，换成下划线‘_’进行分隔。</font>例如：</p><pre><code>{    "account": {        "id": 12345,        "name": "bigo-lv",        "is_admin": false    },    "profile": {        "username":"Dipper",         "age": 21,         "avatar": "http://xxxxxx"    }}// 替换成如下：{    "account_id": 12345,    "account_name": "bigo-lv",    "account_is_admin": false,    "profile_username": "Dipper",     "profile_age": 21,     "profile_avatar": "http://xxxxxx"}</code></pre><h3 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h3><h4 id="headers-1"><a href="#headers-1" class="headerlink" title="headers"></a>headers</h4><ul><li><strong>Content-Type</strong>： application/json；</li><li><strong>X-Request-ID</strong>：在响应头中包含对应请求的 Request-Id，可以方便地跟踪诊断请求，分析日志。</li></ul><h4 id="body-1"><a href="#body-1" class="headerlink" title="body"></a>body</h4><p>响应内容格式为 json 格式，并且以字面编码多字节 Unicode 字符，避免中文被转换成 \uXXXX 的形式，提高可读性并且避免增加数据大小。例如:</p><pre><code>HTTP 1.1 200 OKContent-Type: application/json{    "id":1,    "mobile":"13800138000",    "name":"演示用户",    "email":"demo@example.com"}</code></pre><p><font color="red">注意：对于无需返回内容的请求，应该使用 204 状态码，并且无 body 信息。</font>例如:</p><pre><code>HTTP 1.1 204 OKContent-Type: application/json</code></pre><ul><li><p>正常响应的数据格式</p><ul><li><p><strong>code</strong>: 业务处理的状态（默认：200）</p></li><li><p><strong>message</strong>: 提示信息（默认：success）</p></li><li><p><strong>data</strong>: 具体的业务数据（默认：空对象 ‘{}’）</p><p>  <font color="red"> 注意：API 协议中约定 data 为数组‘[]’，当无数据返回时，要保持 data 为空数组‘[]’，这样可以方便客户端统一处理数据格式。</font></p><pre><code>HTTP 1.1 200 OKContent-Type: application/json{  "code": 200,  "message": "success",  "data" {      "id":1,      "mobile":"13800138000",      "name":"演示用户",      "email":"demo@example.com"  }}</code></pre></li></ul></li><li><p>错误响应的数据格式</p><ul><li><p><strong>code</strong>: 业务处理的状态，使用7位数字表示，前三位用Http Status Code占位，后4位表示业务逻辑错误code。</p></li><li><p><strong>message</strong>: 提示信息，将错误码翻译成用户能理解的提示信息。</p></li><li><p><strong>data</strong>: 具体的错误信息（默认：空对象 ‘{}’）</p><pre><code>HTTP 1.1 401 UnauthorizedContent-Type: application/json{  "code": 4011000,  "message": "用户账号不存在，请确认！",  "data" {}}</code></pre></li></ul></li></ul><h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><blockquote><p>防止客户端透传过来的参数被非法篡改。</p></blockquote><ul><li>对 Request 参数按 key 进行升序（降序）排列后，取出key、value；</li><li>特殊字段：device-id、client-ip、client-id、client-secret、timestamp、api-version；</li><li>截取 URI path 的内容；</li><li>对以上参数进行拼接，md5加密，生成一串字符串，通过 Request Headers 透传给服务端做合法性校验；</li></ul><p><font color="red">注意：具体的加密算法，按实际应用场景定制化处理。</font></p><h2 id="速度限制"><a href="#速度限制" class="headerlink" title="速度限制"></a>速度限制</h2><blockquote><p>为了避免请求泛滥，给API设置速度限制很重要。为此 RFC 6585 引入了HTTP状态码429（too many requests）。<br>加入速度设置之后，应该提示用户，至于如何提示标准上没有说明，不过流行的方法是使用HTTP的返回头。</p></blockquote><p>下面是几个必须的返回头（依照twitter的命名规则）：</p><ul><li><strong>X-Rate-Limit-Limit</strong>: 当前时间段允许的并发请求数；</li><li><strong>X-Rate-Limit-Remaining</strong>: 当前时间段保留的请求数；</li><li><strong>X-Rate-Limit-Reset</strong>: 当前时间段剩余秒数（不用时间戳，避免了时钟偏移问题）；</li></ul><h2 id="分页约定"><a href="#分页约定" class="headerlink" title="分页约定"></a>分页约定</h2><h3 id="Request-1"><a href="#Request-1" class="headerlink" title="Request"></a>Request</h3><blockquote><p>客户端请求时，透传以下参数。</p></blockquote><ul><li><strong>limit</strong>：指定返回记录的数量；</li><li><strong>offset</strong>：指定返回记录的开始位置；</li><li><strong>sortby</strong>：指定返回结果按照哪个属性排序；</li><li><strong>order</strong>：指定返回结果排序顺序（ASC|DESC）；</li></ul><h3 id="Response-1"><a href="#Response-1" class="headerlink" title="Response"></a>Response</h3><blockquote><p>在返回的数据中添加分页信息, 但数据需要再次包装, 以便客户端遍历。 例如：</p></blockquote><pre><code>{    "code": 200,    "message": "success",    "paging": {        "limit":10,        "offset":0,        "total":729    },    "data": []}</code></pre><h2 id="契约-接口-命名规范"><a href="#契约-接口-命名规范" class="headerlink" title="契约(接口)命名规范"></a>契约(接口)命名规范</h2><ul><li>URI 资源名称，应该使用恰当的英文单词或者约定俗成的缩写，保证可读性；</li><li>URI 资源名称，必须符合所有字母都小写；</li><li>URI 资源名称，单词间用 <strong>/</strong> 分隔式的命名规范，一定不能包括 <strong>-_</strong> 分隔符；</li><li>URI 中的名词表示资源集合，使用复数形式；</li><li>URI 中不应该出现动词，动词应该使用HTTP方法表示；</li><li>避免为了过度追求 RESTful风格导致层级过深，适当使用参数表示；</li><li>请求参数，必须符合所有字母都小写，单词间用下划线‘_’分隔的命名规范；</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API协议 </tag>
            
            <tag> 架构设计 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
